   1               		.file	"twislave.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	init_twi_slave
  12               	init_twi_slave:
  13               	.LFB0:
  14               		.file 1 "twislave.c"
   1:twislave.c    **** /*#################################################################################################
   2:twislave.c    **** 	Title	: TWI SLave
   3:twislave.c    **** 	Author	: Martin Junghans <jtronics@gmx.de>
   4:twislave.c    **** 	Hompage	: www.jtronics.de
   5:twislave.c    **** 	Software: AVR-GCC / Programmers Notpad 2
   6:twislave.c    **** 	License	: GNU General Public License 
   7:twislave.c    **** 	
   8:twislave.c    **** 	Aufgabe	:
   9:twislave.c    **** 	Betrieb eines AVRs mit Hardware-TWI-Schnittstelle als Slave. 
  10:twislave.c    **** 	Zu Beginn muss init_twi_slave mit der gewünschten Slave-Adresse als Parameter aufgerufen werden. 
  11:twislave.c    **** 	Der Datenaustausch mit dem Master erfolgt über die Buffer rxbuffer und txbuffer, auf die von Maste
  12:twislave.c    **** 	rxbuffer und txbuffer sind globale Variablen (Array aus uint8_t).
  13:twislave.c    **** 	
  14:twislave.c    **** 	Ablauf:
  15:twislave.c    **** 	Die Ansteuerung des rxbuffers, in den der Master schreiben kann, erfolgt ähnlich wie bei einem nor
  16:twislave.c    **** 	Man sendet zunächst die Bufferposition, an die man schreiben will, und dann die Daten. Die Bufferp
  17:twislave.c    **** 	automatisch hochgezählt, sodass man mehrere Datenbytes hintereinander schreiben kann, ohne jedesma
  18:twislave.c    **** 	die Bufferadresse zu schreiben.
  19:twislave.c    **** 	Um den txbuffer vom Master aus zu lesen, überträgt man zunächst in einem Schreibzugriff die gewüns
  20:twislave.c    **** 	liest dann nach einem repeated start die Daten aus. Die Bufferposition wird automatisch hochgezähl
  21:twislave.c    **** 	Datenbytes hintereinander lesen kann, ohne jedesmal die Bufferposition zu schreiben.
  22:twislave.c    **** 
  23:twislave.c    **** 	Abgefangene Fehlbedienung durch den Master:
  24:twislave.c    **** 	- Lesen über die Grenze des txbuffers hinaus
  25:twislave.c    **** 	- Schreiben über die Grenzen des rxbuffers hinaus
  26:twislave.c    **** 	- Angabe einer ungültigen Schreib/Lese-Adresse
  27:twislave.c    **** 	- Lesezuggriff, ohne vorher Leseadresse geschrieben zu haben
  28:twislave.c    **** 	
  29:twislave.c    **** 	LICENSE:
  30:twislave.c    ****     This program is free software; you can redistribute it and/or modify
  31:twislave.c    ****     it under the terms of the GNU General Public License as published by
  32:twislave.c    ****     the Free Software Foundation; either version 2 of the License, or
  33:twislave.c    ****     any later version.
  34:twislave.c    **** 
  35:twislave.c    ****     This program is distributed in the hope that it will be useful,
  36:twislave.c    ****     but WITHOUT ANY WARRANTY; without even the implied warranty of
  37:twislave.c    ****     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  38:twislave.c    ****     GNU General Public License for more details.
  39:twislave.c    **** 
  40:twislave.c    **** //#################################################################################################
  41:twislave.c    **** 
  42:twislave.c    **** #include <util/twi.h> 								// Bezeichnungen für Statuscodes in TWSR
  43:twislave.c    **** #include <avr/interrupt.h> 							// behandlung der Interrupts
  44:twislave.c    **** #include <stdint.h> 								// definiert Datentyp uint8_t
  45:twislave.c    **** #include "twislave.h" 								
  46:twislave.c    **** 
  47:twislave.c    **** //#################################### Macros
  48:twislave.c    **** //ACK nach empfangenen Daten senden/ ACK nach gesendeten Daten erwarten
  49:twislave.c    **** #define TWCR_ACK 	TWCR = (1<<TWEN)|(1<<TWIE)|(1<<TWINT)|(1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|(0<<TWWC); 
  50:twislave.c    **** 
  51:twislave.c    **** //NACK nach empfangenen Daten senden/ NACK nach gesendeten Daten erwarten     
  52:twislave.c    **** #define TWCR_NACK 	TWCR = (1<<TWEN)|(1<<TWIE)|(1<<TWINT)|(0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|(0<<TWWC);
  53:twislave.c    **** 
  54:twislave.c    **** //switched to the non adressed slave mode...
  55:twislave.c    **** #define TWCR_RESET 	TWCR = (1<<TWEN)|(1<<TWIE)|(1<<TWINT)|(1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|(0<<TWWC)
  56:twislave.c    **** 
  57:twislave.c    **** //########################################################################################## init_t
  58:twislave.c    **** void init_twi_slave(uint8_t adr)
  59:twislave.c    **** {
  15               		.loc 1 59 0
  16               		.cfi_startproc
  17               	.LVL0:
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
  60:twislave.c    **** 	TWAR= adr; //Adresse setzen
  22               		.loc 1 60 0
  23 0000 8093 BA00 		sts 186,r24
  61:twislave.c    **** 	TWCR &= ~(1<<TWSTA)|(1<<TWSTO);
  24               		.loc 1 61 0
  25 0004 ECEB      		ldi r30,lo8(-68)
  26 0006 F0E0      		ldi r31,0
  27 0008 8081      		ld r24,Z
  28               	.LVL1:
  29 000a 8F7D      		andi r24,lo8(-33)
  30 000c 8083      		st Z,r24
  31               	.LVL2:
  62:twislave.c    **** 	TWCR|= (1<<TWEA) | (1<<TWEN)|(1<<TWIE); 	
  32               		.loc 1 62 0
  33 000e 8081      		ld r24,Z
  34 0010 8564      		ori r24,lo8(69)
  35 0012 8083      		st Z,r24
  63:twislave.c    **** 	buffer_adr=0xFF;  
  36               		.loc 1 63 0
  37 0014 8FEF      		ldi r24,lo8(-1)
  38 0016 8093 0000 		sts buffer_adr,r24
  64:twislave.c    **** 	sei();
  39               		.loc 1 64 0
  40               	/* #APP */
  41               	 ;  64 "twislave.c" 1
  42 001a 7894      		sei
  43               	 ;  0 "" 2
  44               	/* #NOAPP */
  45 001c 0895      		ret
  46               		.cfi_endproc
  47               	.LFE0:
  49               	.global	__vector_24
  51               	__vector_24:
  52               	.LFB1:
  65:twislave.c    **** }
  66:twislave.c    **** 
  67:twislave.c    **** //########################################################################################## ISR (T
  68:twislave.c    **** //ISR, die bei einem Ereignis auf dem Bus ausgelöst wird. Im Register TWSR befindet sich dann 
  69:twislave.c    **** //ein Statuscode, anhand dessen die Situation festgestellt werden kann.
  70:twislave.c    **** ISR (TWI_vect)  
  71:twislave.c    **** {
  53               		.loc 1 71 0
  54               		.cfi_startproc
  55 001e 1F92      		push r1
  56               	.LCFI0:
  57               		.cfi_def_cfa_offset 3
  58               		.cfi_offset 1, -2
  59 0020 0F92      		push r0
  60               	.LCFI1:
  61               		.cfi_def_cfa_offset 4
  62               		.cfi_offset 0, -3
  63 0022 0FB6      		in r0,__SREG__
  64 0024 0F92      		push r0
  65 0026 1124      		clr __zero_reg__
  66 0028 8F93      		push r24
  67               	.LCFI2:
  68               		.cfi_def_cfa_offset 5
  69               		.cfi_offset 24, -4
  70 002a 9F93      		push r25
  71               	.LCFI3:
  72               		.cfi_def_cfa_offset 6
  73               		.cfi_offset 25, -5
  74 002c EF93      		push r30
  75               	.LCFI4:
  76               		.cfi_def_cfa_offset 7
  77               		.cfi_offset 30, -6
  78 002e FF93      		push r31
  79               	.LCFI5:
  80               		.cfi_def_cfa_offset 8
  81               		.cfi_offset 31, -7
  82               	/* prologue: Signal */
  83               	/* frame size = 0 */
  84               	/* stack size = 7 */
  85               	.L__stack_usage = 7
  86               	.LVL3:
  72:twislave.c    **** 	uint8_t data=0;
  73:twislave.c    **** 	switch (TW_STATUS) 								// TWI-Statusregister prüfen und nötige Aktion bestimmen 
  87               		.loc 1 73 0
  88 0030 8091 B900 		lds r24,185
  89 0034 887F      		andi r24,lo8(-8)
  90 0036 8038      		cpi r24,lo8(-128)
  91 0038 01F0      		breq .L4
  92 003a 00F4      		brsh .L5
  93 003c 8036      		cpi r24,lo8(96)
  94 003e 01F4      		brne .L3
  74:twislave.c    **** 		{
  75:twislave.c    **** 		case TW_SR_SLA_ACK: 						// 0x60 Slave Receiver, wurde adressiert	
  76:twislave.c    **** 			TWCR_ACK; 								// nächstes Datenbyte empfangen, ACK danach
  95               		.loc 1 76 0
  96 0040 85EC      		ldi r24,lo8(-59)
  97 0042 8093 BC00 		sts 188,r24
  77:twislave.c    **** 			buffer_adr=0xFF; 						// Bufferposition ist undefiniert
  98               		.loc 1 77 0
  99 0046 8FEF      		ldi r24,lo8(-1)
 100 0048 8093 0000 		sts buffer_adr,r24
  78:twislave.c    **** 			break;
 101               		.loc 1 78 0
 102 004c 00C0      		rjmp .L2
 103               	.L5:
  73:twislave.c    **** 		{
 104               		.loc 1 73 0
 105 004e 883A      		cpi r24,lo8(-88)
 106 0050 01F0      		breq .L7
 107 0052 883B      		cpi r24,lo8(-72)
 108 0054 01F0      		breq .L7
 109 0056 00C0      		rjmp .L3
 110               	.L4:
  79:twislave.c    **** 
  80:twislave.c    **** 		case TW_SR_DATA_ACK: 						// 0x80 Slave Receiver,Daten empfangen
  81:twislave.c    **** 			data=TWDR; 								// Empfangene Daten auslesen
 111               		.loc 1 81 0
 112 0058 8091 BB00 		lds r24,187
 113               	.LVL4:
  82:twislave.c    **** 			if (buffer_adr == 0xFF) 				// erster Zugriff, Bufferposition setzen
 114               		.loc 1 82 0
 115 005c 9091 0000 		lds r25,buffer_adr
 116 0060 9F3F      		cpi r25,lo8(-1)
 117 0062 01F4      		brne .L9
  83:twislave.c    **** 				{
  84:twislave.c    **** 					if(data<=buffer_size)			// Kontrolle ob gewünschte Adresse im erlaubten bereich
 118               		.loc 1 84 0
 119 0064 8531      		cpi r24,lo8(21)
 120 0066 00F4      		brsh .L10
  85:twislave.c    **** 						{
  86:twislave.c    **** 							buffer_adr= data; 		// Bufferposition wie adressiert setzen
 121               		.loc 1 86 0
 122 0068 8093 0000 		sts buffer_adr,r24
 123 006c 00C0      		rjmp .L3
 124               	.L10:
  87:twislave.c    **** 						}
  88:twislave.c    **** 					else
  89:twislave.c    **** 						{
  90:twislave.c    **** 						buffer_adr=0; 				// Adresse auf Null setzen. Ist das sinnvoll?
 125               		.loc 1 90 0
 126 006e 1092 0000 		sts buffer_adr,__zero_reg__
 127 0072 00C0      		rjmp .L3
 128               	.L9:
  91:twislave.c    **** 						}				
  92:twislave.c    **** 					TWCR_ACK;						// nächstes Datenbyte empfangen, ACK danach, um nächstes Byte anzufordern
  93:twislave.c    **** 				}
  94:twislave.c    **** 			else 									// weiterer Zugriff, Daten empfangen
  95:twislave.c    **** 				{
  96:twislave.c    **** 					rxbuffer[buffer_adr]=data; 		// Daten in Buffer schreiben
 129               		.loc 1 96 0
 130 0074 E091 0000 		lds r30,buffer_adr
 131 0078 F0E0      		ldi r31,0
 132 007a E050      		subi r30,lo8(-(rxbuffer))
 133 007c F040      		sbci r31,hi8(-(rxbuffer))
 134 007e 8083      		st Z,r24
 135 0080 00C0      		rjmp .L23
 136               	.LVL5:
 137               	.L7:
  97:twislave.c    **** 					buffer_adr++; 					// Buffer-Adresse weiterzählen für nächsten Schreibzugriff
  98:twislave.c    **** 					if(buffer_adr<(buffer_size-1)) // im Buffer ist noch Platz für mehr als ein Byte
  99:twislave.c    **** 						{
 100:twislave.c    **** 							TWCR_ACK;				// nächstes Datenbyte empfangen, ACK danach, um nächstes Byte anzufordern
 101:twislave.c    **** 						}
 102:twislave.c    **** 					else   							// es kann nur noch ein Byte kommen, dann ist der Buffer voll
 103:twislave.c    **** 						{
 104:twislave.c    **** 							TWCR_NACK;				// letztes Byte lesen, dann NACK, um vollen Buffer zu signaliseren
 105:twislave.c    **** 						}
 106:twislave.c    **** 				}
 107:twislave.c    **** 			break;
 108:twislave.c    **** 
 109:twislave.c    **** 		case TW_ST_SLA_ACK: 						//
 110:twislave.c    **** 		case TW_ST_DATA_ACK: 						// 0xB8 Slave Transmitter, weitere Daten wurden angefordert
 111:twislave.c    **** 
 112:twislave.c    **** 			if (buffer_adr == 0xFF) 				// zuvor keine Leseadresse angegeben! 
 138               		.loc 1 112 0
 139 0082 8091 0000 		lds r24,buffer_adr
 140 0086 8F3F      		cpi r24,lo8(-1)
 141 0088 01F4      		brne .L13
 113:twislave.c    **** 				{
 114:twislave.c    **** 					buffer_adr=0;
 142               		.loc 1 114 0
 143 008a 1092 0000 		sts buffer_adr,__zero_reg__
 144               	.L13:
 115:twislave.c    **** 				}	
 116:twislave.c    **** 			TWDR = txbuffer[buffer_adr]; 			// Datenbyte senden 
 145               		.loc 1 116 0
 146 008e E091 0000 		lds r30,buffer_adr
 147 0092 F0E0      		ldi r31,0
 148 0094 E050      		subi r30,lo8(-(txbuffer))
 149 0096 F040      		sbci r31,hi8(-(txbuffer))
 150 0098 8081      		ld r24,Z
 151 009a 8093 BB00 		sts 187,r24
 152               	.LVL6:
 153               	.L23:
 117:twislave.c    **** 			buffer_adr++; 							// bufferadresse für nächstes Byte weiterzählen
 154               		.loc 1 117 0
 155 009e 8091 0000 		lds r24,buffer_adr
 156 00a2 8F5F      		subi r24,lo8(-(1))
 157 00a4 8093 0000 		sts buffer_adr,r24
 118:twislave.c    **** 			if(buffer_adr<(buffer_size-1)) 		// im Buffer ist mehr als ein Byte, das gesendet werden kann
 158               		.loc 1 118 0
 159 00a8 8091 0000 		lds r24,buffer_adr
 160 00ac 8331      		cpi r24,lo8(19)
 161 00ae 00F0      		brlo .L3
 119:twislave.c    **** 				{
 120:twislave.c    **** 					TWCR_ACK; 						// nächstes Byte senden, danach ACK erwarten
 121:twislave.c    **** 				}
 122:twislave.c    **** 			else
 123:twislave.c    **** 				{
 124:twislave.c    **** 					TWCR_NACK; 						// letztes Byte senden, danach NACK erwarten
 162               		.loc 1 124 0
 163 00b0 85E8      		ldi r24,lo8(-123)
 164 00b2 00C0      		rjmp .L21
 165               	.L3:
 125:twislave.c    **** 				}
 126:twislave.c    **** 			break;
 127:twislave.c    **** 
 128:twislave.c    **** 		case TW_ST_DATA_NACK: 						// 0xC0 Keine Daten mehr gefordert 
 129:twislave.c    **** 		case TW_SR_DATA_NACK: 						// 0x88 
 130:twislave.c    **** 		case TW_ST_LAST_DATA: 						// 0xC8  Last data byte in TWDR has been transmitted (TWEA = 0); AC
 131:twislave.c    **** 		case TW_SR_STOP: 							// 0xA0 STOP empfangen
 132:twislave.c    **** 		default: 	
 133:twislave.c    **** 			TWCR_RESET; 							// Übertragung beenden, warten bis zur nächsten Adressierung
 166               		.loc 1 133 0
 167 00b4 85EC      		ldi r24,lo8(-59)
 168               	.L21:
 169 00b6 8093 BC00 		sts 188,r24
 170               	.L2:
 171               	/* epilogue start */
 134:twislave.c    **** 			break;	
 135:twislave.c    **** 		} //end.switch (TW_STATUS)
 136:twislave.c    **** } //end.ISR(TWI_vect)...
 172               		.loc 1 136 0
 173 00ba FF91      		pop r31
 174 00bc EF91      		pop r30
 175 00be 9F91      		pop r25
 176 00c0 8F91      		pop r24
 177 00c2 0F90      		pop r0
 178 00c4 0FBE      		out __SREG__,r0
 179 00c6 0F90      		pop r0
 180 00c8 1F90      		pop r1
 181 00ca 1895      		reti
 182               		.cfi_endproc
 183               	.LFE1:
 185               		.comm	buffer_adr,1,1
 186               		.comm	txbuffer,20,1
 187               		.comm	rxbuffer,20,1
 188               	.Letext0:
 189               		.file 2 "twislave.h"
 190               		.file 3 "c:\\program files (x86)\\mhv avr tools\\avr\\include\\stdint.h"
DEFINED SYMBOLS
                            *ABS*:00000000 twislave.c
C:\Users\lars\AppData\Local\Temp\ccajIEkN.s:2      *ABS*:0000003e __SP_H__
C:\Users\lars\AppData\Local\Temp\ccajIEkN.s:3      *ABS*:0000003d __SP_L__
C:\Users\lars\AppData\Local\Temp\ccajIEkN.s:4      *ABS*:0000003f __SREG__
C:\Users\lars\AppData\Local\Temp\ccajIEkN.s:5      *ABS*:00000000 __tmp_reg__
C:\Users\lars\AppData\Local\Temp\ccajIEkN.s:6      *ABS*:00000001 __zero_reg__
C:\Users\lars\AppData\Local\Temp\ccajIEkN.s:12     .text:00000000 init_twi_slave
                            *COM*:00000001 buffer_adr
C:\Users\lars\AppData\Local\Temp\ccajIEkN.s:51     .text:0000001e __vector_24
                            *COM*:00000014 rxbuffer
                            *COM*:00000014 txbuffer

UNDEFINED SYMBOLS
__do_clear_bss
