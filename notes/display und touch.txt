https://github.com/notro/fbtft/wiki

---------------- muss jedes mal per modprobe gestartet werden ----------------

--- install ---

FBTFT drivers as loadable modules (muss jedes mal per modprobe gestartet werden):
sudo apt-get update
sudo REPO_URI=https://github.com/notro/rpi-firmware rpi-update

sudo nano /usr/share/X11/xorg.conf.d/99-fbturbo.conf
        Option          "fbdev" "/dev/fb1"

sudo reboot

--- starten ---

sudo modprobe fbtft_device custom name=fb_ili9341 width=240 height=320 rotate=180 speed=80000000 buswidth=8 bgr=1 gpios=reset:25,led:18,dc:24 cs=0
dmesg
lsmod
ls /dev/fb*

---------------- bootkonsole wird direkt angezeigt ----------------

--- install ---
 
FBTFT drivers built into the kernel proper (bootkonsole wird direkt angezeigt):
sudo apt-get update
sudo REPO_URI=https://github.com/notro/rpi-firmware BRANCH=builtin rpi-update

muss alles inkl dem was schon drin ist in einer zeile stehen:
sudo nano /boot/cmdline.txt
dwc_otg.lpm_enable=0 console=tty1 root=/dev/mmcblk0p2 rootfstype=ext4 elevator=deadline rootwait fbtft_device.custom fbtft_device.name=fb_ili9341 fbtft_device.width=240 fbtft_device.height=320 fbtft_device.rotate=180 fbtft_device.speed=80000000 fbtft_device.buswidth=8 fbtft_device.bgr=1 fbtft_device.gpios=reset:25,led:18,dc:24 fbtft_device.cs=0 fbtft_device.debug=0 fbtft_device.verbose=0 fbcon=map:10 fbcon=font:ProFont6x11 logo.nologo

sudo nano /usr/share/X11/xorg.conf.d/99-fbturbo.conf
        Option          "fbdev" "/dev/fb1"

cat /proc/cmdline | wc -c

---------------- bildschirm nicht schlafen schicken ----------------

view:
cat /sys/module/kernel/parameters/consoleblank

change:
sudo nano /etc/kbd/config
BLANK_TIME=0

---------------- testen ----------------

FRAMEBUFFER=/dev/fb1 startx
./fbtest/fbtest --fbdev /dev/fb1
con2fbmap 1 1
con2fbmap 1 0
cat /dev/urandom > /dev/fb1
cat /dev/zero > /dev/fb1

---------------- tester installieren ----------------

sudo su
apt-get install libnetpbm10-dev
git clone https://git.kernel.org/pub/scm/linux/kernel/git/geert/fbtest.git
cd fbtest
make
./fbtest --fbdev /dev/fb1
cd ..

------ beim start laden ------

export SDL_FBDEV=/dev/fb1
export SDL_VIDEODRIVER=fbcon



------ notizen ------

console blanking:
https://github.com/notro/fbtft/wiki/Boot-console

https://github.com/notro/fbtft/blob/master/fbtft_device.c

display: ili9341
touch: xpt2046

gcc a.c `pkg-config --libs --cflags directfb`

------ speed ------
speed=100000000
weiss
speed=90000000
weiss
speed=80000000
Benchmarking... 10x10 squares: 22.47 Mpixels/s
Benchmarking... 20x20 squares: 47.16 Mpixels/s
Benchmarking... 50x50 squares: 97.79 Mpixels/s
Benchmarking... 100x100 squares: 132.10 Mpixels/s
Benchmarking... 200x200 squares: 144.01 Mpixels/s

------ wenn das display nicht mehr will ------

sudo apt-get update
sudo REPO_URI=https://github.com/notro/rpi-firmware rpi-update
sudo REPO_URI=https://github.com/notro/rpi-firmware BRANCH=builtin rpi-update

------ wenn x nicht will ------

sudo nano /usr/share/X11/xorg.conf.d/99-fbturbo.conf
        Option          "fbdev" "/dev/fb1"

----------------------------- touch -----------------------------


---------------- muss jedes mal per modprobe gestartet werden ----------------

----- installieren -----
#xinput dient zum Vertauschen der Achsen
#evtest dient zum Testen und Kalibrieren des Touchpanells
sudo apt-get -y install xinput evtest


sudo modprobe ads7846 #?????????

sudo modprobe ads7846_device cs=1 speed=2000000 model=7843 x_plate_ohms=60 pressure_max=255 gpio_pendown=27 keep_vref_on=1 x_min=500 x_max=3615 y_min=280 y_max=3583

FRAMEBUFFER=/dev/fb1 startx &
DISPLAY=:0 xinput --set-prop 'ADS7843 Touchscreen' 'Evdev Axis Inversion' 0 1


#Kalibrieren und Parameter siehe Seite 5
#eventnummer (event2) ggf. anpassen!

evtest /dev/input/event2 | egrep ABS_PRESSURE
evtest /dev/input/event2 | grep ABS_Y
evtest /dev/input/event2 | grep ABS_X
#Damit Touchscreen automatisch beim Booten geladen wird, in /etc/modules (kernel modules to load at boot time) als neue Zeile einfügen: ads7846_device cs=1 speed=2000000 model=7843 x_plate_ohms=60 pressure_max=255 gpio_pendown=17 keep_vref_on=1 x_min=500 x_max=3615 y_min=280 y_max=3583



Wiring
Display
Raspberry Pi
Note
T_CLK
SCLK

T_DIN
MOSI

T_DOUT
MISO

T_CS
CE1

T_IRQ
GPIOn
must be matched with ads7846 parameter gpio_pendown

ads7846_device 
ads7846_device is a kernel module for registering an ads7846 device.

sudo modprobe ads7846_device arguments
Arguments
busnum - SPI bus number (default=0)
cs - SPI chip select (default=1)
speed - SPI speed (default 2MHz)
irq
mode - SPI mode (default: SPI_MODE_0)
verbose - 0-2
model - 7843, 7845, 7846, 7873 (default: 7846)
vref_delay_usecs - 0 for external vref; etc
micro seconds to delay between SPI transfers (spi_transfer.delay_usecs)
vref_mv - external vref value, milliVolts ads7846: if 0, use internal vref
used for hwmon sensor code
keep_vref_on - set to keep vref on for differential measurements as well
used in ads7846_setup_spi_msg(). READ_X(vref) == ADS_START | ADS_A2A1A0_d_ x | ADS_12_BIT | ADS_DFR | ADS_PD10_ADC_ON | (vref ? ADS_PD10_REF_ON : 0)
#define ADS_PD10_REF_ON (2 << 0) /* vREF on + penirq */ 
swap_xy - swap x and y axes
settle_delay_usecs - Settling time of the analog signals; a function of Vcc and the capacitance on the X/Y drivers.
If set to non-zero, two samples are taken with settle_delay us apart, and the second one is used. ~150 uSec with 0.01uF caps.
micro seconds to delay between SPI transfers (spi_transfer.delay_usecs)
penirq_recheck_delay_usecs - If set to non-zero, after samples are taken this delay is applied and penirq is rechecked,
to help avoid false events. This value is affected by the material used to build the touch layer.
used in ads7846_report_state udelay(ts->penirq_recheck_delay_usecs); 
x_plate_ohms - Used to calculate pressure in ads7846_report_state() (default: 400)
y_plate_ohms - Not used by driver
x_min - Minimum value for x-axis (default: 0)
x_max - Maximum value for x-axis (default: MAX_12BIT == 0x0FFF == 4095)
input_set_abs_params(input_dev, ABS_X, pdata->x_min ? : 0, pdata->x_max ? : MAX_12BIT, 0, 0);
from include/uapi/linux/input.h: Resolution for main axes (ABS_X, ABS_Y, ABS_Z) is reported in units per millimeter (units/mm)
y_min - Minimum value for y-axis (default: 0)
y_max - Maximum value for y-axis (default: MAX_12BIT == 0x0FFF == 4095)
input_set_abs_params(input_dev, ABS_Y, pdata->y_min ? : 0, pdata->y_max ? : MAX_12BIT, 0, 0); 
pressure_min, pressure_max - (pressure_max default: ~0 == 0xFFFF)
input_set_abs_params(input_dev, ABS_PRESSURE, pdata->pressure_min, pdata->pressure_max, 0, 0); 
debounce_max - max number of additional readings per sample (0,1,2)
if filter is not defined and debounce_max is non-zero, filter will be ads7846_debounce_filter() 
debounce_tol - tolerance used for filtering
used in ads7846_debounce_filter
debounce_rep - additional consecutive good readings required after the first two
used in ads7846_debounce_filter
gpio_pendown - the GPIO used to decide the pendown state if get_pendown_state == NULL
irq_flags - (default: IRQF_TRIGGER_FALLING)
Max SPI speed
Max SPI speed is: 125000 * (8+16+2) Hz = 125000 * 26 Hz = 3250 kHz
On the Raspberry Pi, we have two close values on this list: 1.9 MHz and 3.9 MHz
Asking for 2 MHz will rount down to neares value which i 1.935 MHz
The value 125000 probably comes from Datasheet - ELECTRICAL CHARACTERISTICS:
|-----------------------------------------------------------|
|                                 |    ADS7846E     |       |
| PARAMETER          | CONDITIONS | MIN | TYP | MAX | UNITS |
|-----------------------------------------------------------|
| Throughput Rate    |            |     |     | 125 | kHz   | 
|-----------------------------------------------------------|
Excerpt from ads7846.c
/* this driver doesn't aim at the peak continuous sample rate */
#define SAMPLE_BITS (8 /*cmd*/ + 16 /*sample*/ + 2 /* before, after */)

static int __devinit ads7846_probe(struct spi_device *spi)

    /* don't exceed max specified sample rate */
    if (spi->max_speed_hz > (125000 * SAMPLE_BITS)) {
        dev_dbg(&spi->dev, "f(sample) %d KHz?\n",
                (spi->max_speed_hz/SAMPLE_BITS)/1000);
        return -EINVAL;
    }

ADS7846 driver calibration (https://github.com/notro/fbtft_tools/wiki/ads7846_device)
Try both finger and stylus when calibrating.
Pressure
x_plate_ohms controls pressure.
Load driver with x_plate_ohms=400.
Tip: Hook up a LED to IRQ to see when the controller detects something. 
Monitor pressure events
evtest /dev/input/eventX | egrep ABS_PRESSURE
If no event is detected, lower the value by half and reload the driver until a satisfying value is found.
x_min, x_max, y_min, y_max
Load driver with the x_plate_ohm value, and without x_ and y_ values.
Monitor positioning events
evtest /dev/input/eventX | grep ABS_X
evtest /dev/input/eventX | grep ABS_Y
Press a stylus at the outher edges of the display to record the min/max x and y value.
swap_xy
Swaps the X and Y axis. Used in landscape mode.
Links
linux/spi/ads7846.h
drivers/input/touchscreen/ads7846.c
Application notes:
Touch screen controller tips
Operation Schemes of Touch Screen Controllers
Inversion pathces
http://git.openembedded.org/openembedded/plain/recipes/linux/linux-omap-2.6.29/omap3-touchbook/touchscreen-ads7846-rotation-support.patch
http://git.openembedded.org/openembedded/plain/recipes/linux/linux-omap-pm-2.6.29/omap3-touchbook/touchscreen-ads7846-rotation-fixed.patch

Videos abspielen
Ein nettes Feature ist Videos auf dem Display laufen zu lassen. Das geht entweder indem du die Datei mühselig im Verzeichnis suchst oder einfach einen Player per Konsole startest. Letzteres zeige ich einmal kurz:
Als erstes brauchst du einen Player (z.B. den mplayer).
sudo apt-get install -y mplayer
Falls du ein Video auf dem Pi hast, kannst du jenes nehmen, ansonsten einfach testweise eines herunterladen:
wget http://download.blender.org/peach/bigbuckbunny_movies/big_buck_bunny_480p_surround-fix.avi
Und nun kannst du es auch bereits abspielen (zusätzliche Optionen kannst du hier einsehen).
mplayer -nolirc -vo fbdev2:/dev/fb1 -vf scale=320:-3 big_buck_bunny_480p_surround-fix.avi
